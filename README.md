**Read in other languages: [Русский](README.md), [Polska](README.pl.md).**

# React homework template

Этот проект был создан при помощи
[Create React App](https://github.com/facebook/create-react-app). Для знакомства
и настройки дополнительных возможностей
[обратись к документации](https://facebook.github.io/create-react-app/docs/getting-started).

## Подготовка нового проекта

1. Убедись что на компьютере установлена LTS-версия Node.js.
   [Скачай и установи](https://nodejs.org/en/) её если необходимо.
2. Склонируй этот репозиторий.
3. Измени имя папки с `react-homework-template` на имя своего проекта.
4. Создай новый пустой репозиторий на GitHub.
5. Открой проект в VSCode, запусти терминал и свяжи проект с GitHub-репозиторием
   [по инструкции](https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories#changing-a-remote-repositorys-url).
6. Установи базовые зависимости проекта командой `npm install`.
7. Запусти режим разработки, выполнив команду `npm start`.
8. Перейди в браузере по адресу [http://localhost:3000](http://localhost:3000).
   Эта страница будет автоматически перезагружаться после сохранения изменений в
   файлах проекта.

## Деплой

Для настройки деплоя проекта необходимо выполнить несколько дополнительных шагов
по настройке твоего репозитория. Зайди во вкладку `Settings` и в подсекции
`Actions` выбери выбери пункт `General`.

![GitHub actions settings](./assets/actions-config-step-1.png)

Пролистай страницу до последней секции, в которой выбери опции как на следующем
изображении и нажми `Save`. Без этих настроек у сборки будет недостаточно прав
для автоматизации процесса деплоя.

![GitHub actions settings](./assets/actions-config-step-2.png)

Продакшн версия проекта будет автоматически проходить линтинг, собираться и
деплоиться на GitHub Pages, в ветку `gh-pages`, каждый раз когда обновляется
ветка `main`. Например, после прямого пуша или принятого пул-реквеста. Для этого
необходимо в файле `package.json` отредактировать поле `homepage`, заменив
`your_username` и `your_repo_name` на свои, и отправить изменения на GitHub.

```json
"homepage": "https://your_username.github.io/your_repo_name/"
```

Далее необходимо зайти в настройки GitHub-репозитория (`Settings` > `Pages`) и
выставить раздачу продакшн версии файлов из папки `/root` ветки `gh-pages`, если
это небыло сделано автоматически.

![GitHub Pages settings](./assets/repo-settings.png)

### Статус деплоя

Статус деплоя крайнего коммита отображается иконкой возле его идентификатора.

- **Желтый цвет** - выполняется сборка и деплой проекта.
- **Зеленый цвет** - деплой завершился успешно.
- **Красный цвет** - во время линтинга, сборки или деплоя произошла ошибка.

Более детальную информацию о статусе можно посмотреть кликнув по иконке, и в
выпадающем окне перейти по ссылке `Details`.

![Deployment status](./assets/status.png)

### Живая страница

Через какое-то время, обычно пару минут, живую страницу можно будет посмотреть
по адресу указанному в отредактированном свойстве `homepage`. Например, вот
ссылка на живую версию для этого репозитория
[https://goitacademy.github.io/react-homework-template](https://goitacademy.github.io/react-homework-template).

Если открывается пустая страница, убедись что во вкладке `Console` нет ошибок
связанных с неправильными путями к CSS и JS файлам проекта (**404**). Скорее
всего у тебя неправильное значение свойства `homepage` в файле `package.json`.

### Маршрутизация

Если приложение использует библиотеку `react-router-dom` для маршрутизации,
необходимо дополнительно настроить компонент `<BrowserRouter>`, передав в пропе
`basename` точное название твоего репозитория. Слеши в начале и конце строки
обязательны.

```jsx
<BrowserRouter basename="/your_repo_name/">
  <App />
</BrowserRouter>
```

## Как это работает

![How it works](./assets/how-it-works.png)

1. После каждого пуша в ветку `main` GitHub-репозитория, запускается специальный
   скрипт (GitHub Action) из файла `.github/workflows/deploy.yml`.
2. Все файлы репозитория копируются на сервер, где проект инициализируется и
   проходит линтинг и сборку перед деплоем.
3. Если все шаги прошли успешно, собранная продакшн версия файлов проекта
   отправляется в ветку `gh-pages`. В противном случае, в логе выполнения
   скрипта будет указано в чем проблема.

   ***

4. Компонент-класс, в отличие от компонента-функции способен хранить состояние
   объекта (State), которое изменяется методами самого класса

5. Создаваемый экземляр класса расширяет родительский подкласс React.Component

export class FeedbackCounter extends React.Component {}

3.  События на определенном элементе регистрируются с помощью специального
    пропа, например onClick. В реакте под капотом реализовано глобальное
    делегирование событий, а мы просто регистрируем (ловим) событие на элементе.
    Передаем обычную стрелку -- инлайн-коллбек.

4.  Если логика инлайн-коллбека большая, то необходимо его вывести в отдельную
    функцию - метод класса. В коллбе нее забыть добавить this.!

5.  Обычная функция (в нашем случае, метод класса) получает свой контекст не в
    момент определения, а в момент вызова. Поэтому, вызываясь в коллбеке (по
    ссылке на себя), она уже не будет иметь контекста нашего экземпляра класса.
    Поэтому метод класса мы превратим в ПУБЛИЧНОЕ СВОЙСТВО, а именно, функцию
    заменим стрелкой. Стрелка получает свой контекст в моент своего определения,
    поэтому контекст экземпляра класса теперь навсегда с ней.

6.  Регистрация слушателя события. Нативный Event, который приходит на событие,
    автоматически оборачивается синтетическим SyntheticEvent Object -
    кроссбраузерная обёртка реакта. Однако интерфейс у нее такой же,как и у
    нативного ивента.

    !!НО глобальное делегирование, объект событий всего лишь один и он просто
    переиспользуется. В SyntheticEvent Object передается ссылка на текущее
    событие, которая сразу же очищается, поэтому данные будут доступны только в
    синхронном коде. Если нужно использовать данные SyntheticEvent Object в
    асинхронном коде, то надо присваивать его значение доп переменной или же
    делать деструктуризацию.

7.  Пользователь кликает - вызывается метод класса - обновляется состояне
    экземпляра класса - реакт перерендеривает виртуальный дом и обновляет
    изменившийся элемент.

Регистрируем состояние класса STATE - ЭТО ВСЕГДА ОБЪЕКТ. Раньше было:

constructor(){

super(); //вызов конструктора родителя внутри конструктора ребенка

    this.state = {

      good: 0,

      neutral: 0,

      bad: 0,

      свойства, тут можно хранить любую вложенность, только не функции}

    }

8. Т.к. в сборке есть транспилятор Babel, мы можем не писать конструктор, а
   просто объявить публичное свойство state.

state = { good: 0, neutral: 0, bad: 0, };

9. Обновление состояния state - перезаписать. !!! Напрямую обновлять состояние
   класса НЕЛЬЗЯ!

Используем метод setState (update, callback) - куда передается только ОБЪЕКТ,
состояние которого мы хотим обновить, не основываясь на предыдущем состоянии. В
коллбек можно передать функцию, которая вызовется только тогда, когда состояние
state обновится - асинхронность. Похоже на setTimeout.

10. Обновить состояние state в зависимости от предыдущего состояния (например,
    увеличение значения на 1 при клике) - передаем в setState не объект, а
    ФУНКЦИЮ, аргументом которой является копия предыдущего состояния объекта -
    prevState!

11. Если значения состояния передаются пропсами, то обязательно указываем
    дефолтные значения в static свойстве и их проптайпы.

12. Создаем КОМПОЗИЦИЮ. Если мы выносим части разметки из рендера в другие
    компоненты, то методы для них передаём пропсами (интерполяция). Внегласное
    правило имён пропсов для передаваемых МЕТОДОВ -- добавляем приставку on
    (напр, onHandleIncrement)

13. DOM перерендеривается, когда приходят новые пропы или когда меняется
    внутреннее состояние.

Паттерн Подъем состояния В родителе есть состояние и метод который его изменяет.
Ребенку, в виде пропа, пробрасывается метод родителя изменяющий состояние
родителя. В ребенке происходит вызов переданного ему метода. При вызове этого
метода изменяется состояние родителя. Происходит ре-рендер поддерева компонентов
родителя.




___________________________________________________________________________________-

*ХУКИ*

 Хуки позволяют удобнее переиспользовать код, он получается чище и структурированнее. Использование хуков позволяет отойти от использования классов.
Вместе с классми можно использовать хуки, но не внутри класса.


1. useState - для использования state внутри функции
import {useState} from "react"

В хуках не хранится предыдущее значение стейта, им нужно передавать полностью целое обновление. В хуках не хранят объекты, для каждого свойства делают отдеьный хук. 

Передаем в useState начальное состояние какого-то свойства стейта, оно возвращает массив данных, где первое значение - имя свойства, а второе - метод для его обновления (напр, setEmail, setPassword)

2. Пропсы, которые приходят, теперь доступны как аргументы функции (без контекста this)

3. Изменяется только концепция управления состоянием.

Если меняется значение от предыдущего, то обязательно используем стрелку с prevState (просто переписывать существующее значение нельзя).

4. Как заменить методы жизненного цикла? 

useEffect - синхронизация внутреннего состояния компонентов с чем-то внешним. В него передается функция, которая будет выполняться каждый раз, когда меняется проп или стейт. Эта функция ВСЕГДА АНОНИМНАЯ (внутри можно объявлять другие функции).

! Хуки нельзя вызывать по условию ! оии ни во что не вложены, должны быть на верхнем уровне области видимости функции.

Вторым аргуметом в useEffect передают зависимости.
Если передать вторым аргументом пустой массив [], то useEffect вызовется только при первом рендере и больше НИКОГДА!

Если второго аргумента нет, то useEffect запускается каждый раз при изменении пропа или стейта.

Если в массив зависимостей (второй аргумент) записать имя определенного свойства, то useEffect будет вызываться только при изменении этого свойства.
Это заменит нам проверки логические равенства, которые мы использовали в классах.

Таким образом, с помощью useEffect мы заменяем ComponentDidMount и ComponentDidUpdate.

useEffect можно использовать сколько угодно раз.

5. Чтобы записывать изменения полей формы в Локал Стораж, теперь вместо ComponentDidUpdate мы используем useEffect с зависимостями. Отдельный useEffect для каждого поля (и разный локал стораж, соответственно). / window.localStorage.setItem()/

6. Оператор ?? - аналог ||, но к false приводит только значения undefind и null (т.е. 0 и "" для него валидны)

7. В useState начальным значением можно записать window.localStorage.getItem().

8. LAZY STATE INITIALIZATION - ленивая инициализация состояний. Если значение useState зависит от какого-либо выражения, то используем LAZY STATE INITIALIZATION

Особенность интерпертатора js - обращение к локал сторажу будет вызываться при каждом рендере:

const [email, setEmail] = useState(JSON.parse(window.localStorage.getItem('email')));

Чтобы это предотвратить, передаем в useState - функцию, которая вернет результат наших рассчетов. Тогда обращение к локал сторажу произойдет 1 раз при первом рендере:

const [email, setEmail] = useState(()=>{return(JSON.parse(window.localStorage.getItem('email')))});

9. КАСТОМНЫЙ ХУК (обычно они хранятся в отдельной папке)
Не забывать вернуть массив состояний.

10. useRef - обычно используется, чтобы получить ссылку на какой-либо DOM-узел, но также его можно ипользовать для сохранения стабильного значения между рендерами.

Если мы создадим переменную в функции и зададим ей начальное значение, то при каждом выполнении функции, переменная будет снова принимать это заданное начальное значание - сбрасываться -  (т.к. функция всегда выполняется целиком). Чтобы этого избежать:

const a = useRef('null'); - в переменную запишется неизменная ссылка на объект, у которого будет свойство current,  - !!вызовется только при первом рендерею
Поэтому то значение, которое должно оставаться неизменным (не сбрасывалось) после каждого последующего рендера (например, id), мы записываем на 

a.current = ...

11. То, что мы возвращаем из useEffect - это функция очистки компонента перед следующим вызовом useEffect

 return()=>{console.log('изменилось'), []}; - если зависимостей нет, то это вызовется перед последним рендером.

 Чтобы вызвать useEffect, можно на событие (напр, onClick) повесить действие (функция-анонимка), которая будет менять стейт каким-либо образом








